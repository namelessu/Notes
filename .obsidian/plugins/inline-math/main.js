/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoMoreFlicker
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");
var import_state2 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/key.ts
var import_obsidian = require("obsidian");
var asKey = (event) => {
  const { key, ctrlKey, metaKey, shiftKey, altKey } = event;
  return { key, ctrlKey, metaKey, shiftKey, altKey };
};
var is = (event, key) => {
  return key.key == event.key && key.ctrlKey == event.ctrlKey && key.metaKey == event.metaKey && key.shiftKey == event.shiftKey && key.altKey == event.altKey;
};
var toString = (key) => {
  let ret = "";
  if (key.ctrlKey)
    ret += "Ctrl + ";
  if (key.shiftKey)
    ret += "Shift + ";
  if (key.metaKey)
    ret += import_obsidian.Platform.isMacOS || import_obsidian.Platform.isIosApp ? "Cmd + " : import_obsidian.Platform.isWin ? "Win + " : "Meta + ";
  if (key.altKey)
    ret += import_obsidian.Platform.isMacOS || import_obsidian.Platform.isIosApp ? "Option + " : "Alt + ";
  ret += key.key.charAt(0).toUpperCase() + key.key.slice(1);
  return ret;
};
var noneKey = {
  key: "",
  ctrlKey: false,
  metaKey: false,
  shiftKey: false,
  altKey: false
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  deletionKeys: [
    {
      key: "Backspace",
      ctrlKey: false,
      metaKey: false,
      shiftKey: false,
      altKey: false
    },
    {
      key: "h",
      ctrlKey: true,
      metaKey: false,
      shiftKey: false,
      altKey: false
    }
  ],
  disableDecorations: false,
  disableAtomicRanges: false
};
var NoMoreFlickerSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const setting = new import_obsidian2.Setting(containerEl).setName("Register deletion keys");
    const list = containerEl.createEl("ul");
    const listDeletionKeys = () => {
      list.replaceChildren(
        ...this.plugin.settings.deletionKeys.map((key) => {
          const item = createEl("li", { text: "" });
          new import_obsidian2.Setting(item).setName(toString(key)).addExtraButton((btn) => {
            btn.setIcon("x").onClick(async () => {
              this.plugin.settings.deletionKeys.remove(key);
              listDeletionKeys();
              await this.plugin.saveSettings();
            });
          });
          return item;
        })
      );
    };
    listDeletionKeys();
    setting.addButton((button) => {
      button.setIcon("plus").onClick(() => {
        this.plugin.settings.deletionKeys.push(noneKey);
        button.setButtonText("Press deletion keys...");
        this.plugin.registerDomEvent(button.buttonEl, "keydown", (event) => {
          this.plugin.settings.deletionKeys[this.plugin.settings.deletionKeys.length - 1] = asKey(event);
          listDeletionKeys();
          if (list.lastChild instanceof HTMLElement) {
            new import_obsidian2.ButtonComponent(list.lastChild).setButtonText("Save").onClick(async () => {
              await this.plugin.saveSettings();
              this.display();
            });
          }
        });
      });
    });
    containerEl.createEl("h6", { text: "Debug mode" });
    new import_obsidian2.Setting(containerEl).setName("Disable decorations").setDesc("If turned on, decorations to hide brackets adjacent to dollar signs are disabled.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableDecorations).onChange(async (disable) => {
        this.plugin.settings.disableDecorations = disable;
        this.plugin.remakeViewPlugin();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Disable atomic ranges").setDesc(createFragment((el) => {
      el.createSpan({ text: 'If turned on, atomic ranges to treat "' });
      el.createEl("code", { text: "${} " });
      el.createSpan({ text: '" or "' });
      el.createEl("code", { text: " {}$" });
      el.createSpan({ text: '" as one character are disabled.' });
    })).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableAtomicRanges).onChange(async (disable) => {
        this.plugin.settings.disableAtomicRanges = disable;
        this.plugin.remakeViewPlugin();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).addButton((button) => {
      button.setButtonText("Restore defaults").onClick(async () => {
        this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
        listDeletionKeys();
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
};

// src/handlers.ts
var import_language = require("@codemirror/language");

// src/node_names.ts
var INLINE_MATH_BEGIN = "formatting_formatting-math_formatting-math-begin_keyword_math";
var MATH_END = "formatting_formatting-math_formatting-math-end_keyword_math_math-";

// src/utils.ts
function nodeText(node, state) {
  return state.sliceDoc(node.from, node.to);
}
function isInlineMathBegin(node, state) {
  return node.name == INLINE_MATH_BEGIN && nodeText(node, state) == "$";
}
function isInlineMathEnd(node, state) {
  return node.name == MATH_END && nodeText(node, state) == "$";
}

// src/handlers.ts
function deletionHandler(view) {
  const range = view.state.selection.main;
  const from = range.empty ? range.from - 4 : range.from;
  const to = range.to;
  const text = view.state.sliceDoc(from, to);
  const index = text.lastIndexOf("$");
  if (index == -1) {
    return;
  }
  const doc = view.state.doc.toString();
  const indexNextDollar = doc.indexOf("$", from + index + 1);
  const indexPrevDollar = doc.lastIndexOf("$", from);
  const tree = (0, import_language.syntaxTree)(view.state);
  const changes = [];
  tree.iterate({
    from: indexPrevDollar,
    to: indexNextDollar >= 0 ? indexNextDollar : to,
    enter(node) {
      if (isInlineMathBegin(node, view.state) && view.state.sliceDoc(node.to, node.to + 3) == "{} ") {
        changes.push({ from: node.to, to: node.to + 3 });
      } else if (isInlineMathEnd(node, view.state) && view.state.sliceDoc(node.from - 3, node.from) == " {}") {
        changes.push({ from: node.from - 3, to: node.from });
      }
    }
  });
  view.dispatch({ changes });
}
function insertionHandler(view) {
  const tree = (0, import_language.syntaxTree)(view.state);
  const range = view.state.selection.main;
  const doc = view.state.doc.toString();
  const indexNextDollar = doc.indexOf("$", range.to);
  const indexPrevDollar = doc.lastIndexOf("$", range.from);
  if (indexNextDollar >= 0) {
    tree.iterate({
      from: indexPrevDollar,
      to: indexNextDollar + 1,
      enter(node) {
        if (isInlineMathBegin(node, view.state)) {
          if (!(view.state.sliceDoc(node.to, node.to + 3) == "{} ")) {
            view.dispatch({ changes: { from: node.to, insert: "{} " } });
          }
        } else if (isInlineMathEnd(node, view.state)) {
          if (!(view.state.sliceDoc(node.from - 3, node.from) == " {}")) {
            view.dispatch({ changes: { from: node.from, insert: " {}" } });
          }
        }
      }
    });
  }
}

// src/cleaner.ts
var import_language2 = require("@codemirror/language");
function cleaner(view) {
  const changes = [];
  (0, import_language2.syntaxTree)(view.state).iterate({
    enter(node) {
      if (isInlineMathBegin(node, view.state)) {
        if (view.state.sliceDoc(node.to, node.to + 3) == "{} ") {
          changes.push({ from: node.to, to: node.to + 3 });
        }
      } else if (isInlineMathEnd(node, view.state)) {
        if (view.state.sliceDoc(node.from - 3, node.from) == " {}") {
          changes.push({ from: node.from - 3, to: node.from });
        }
      }
    }
  });
  view.dispatch({ changes });
}
function cleanerCallback(editor) {
  const view = editor.cm;
  if (view) {
    cleaner(view);
  }
}

// src/decoration_and_atomic-range.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_language3 = require("@codemirror/language");
var DummyRangeValue = class extends import_state.RangeValue {
};
var createViewPlugin = (plugin) => import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.impl(view);
    }
    update(update) {
      this.impl(update.view);
    }
    impl(view) {
      const decorationBulder = new import_state.RangeSetBuilder();
      const atomicRangeBulder = new import_state.RangeSetBuilder();
      const tree = (0, import_language3.syntaxTree)(view.state);
      for (const { from, to } of view.visibleRanges) {
        tree.iterate({
          from,
          to,
          enter(node) {
            if (isInlineMathBegin(node, view.state)) {
              if (view.state.sliceDoc(node.to, node.to + 3) == "{} ") {
                decorationBulder.add(
                  node.to,
                  node.to + 3,
                  import_view.Decoration.replace({})
                );
                atomicRangeBulder.add(
                  node.from,
                  node.to + 3,
                  new DummyRangeValue()
                );
              }
            } else if (isInlineMathEnd(node, view.state)) {
              if (view.state.sliceDoc(node.from - 3, node.from) == " {}") {
                decorationBulder.add(
                  node.from - 3,
                  node.from,
                  import_view.Decoration.replace({})
                );
                atomicRangeBulder.add(
                  node.from - 3,
                  node.to,
                  new DummyRangeValue()
                );
              }
            }
          }
        });
      }
      this.decorations = decorationBulder.finish();
      this.atomicRanges = atomicRangeBulder.finish();
    }
  },
  {
    decorations: (instance) => plugin.settings.disableDecorations ? import_view.Decoration.none : instance.decorations,
    provide: (viewPlugin) => import_view.EditorView.atomicRanges.of((view) => {
      var _a, _b;
      return plugin.settings.disableAtomicRanges ? import_state.RangeSet.empty : (_b = (_a = view.plugin(viewPlugin)) == null ? void 0 : _a.atomicRanges) != null ? _b : import_state.RangeSet.empty;
    })
  }
);

// src/main.ts
var NoMoreFlicker = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.viewPlugin = [];
  }
  async onload() {
    await this.loadSettings();
    await this.saveSettings();
    this.addSettingTab(new NoMoreFlickerSettingTab(this.app, this));
    this.registerEditorExtension(this.viewPlugin);
    this.remakeViewPlugin();
    this.registerEditorExtension(import_state2.Prec.highest(import_view2.EditorView.domEventHandlers({
      "keydown": this.onKeydown.bind(this)
    })));
    this.addCommand({
      id: "clean",
      name: "Clean up brackets in this note",
      editorCallback: cleanerCallback
    });
    this.addCommand({
      id: "clean-all",
      name: "Clean up brackets in all the opened notes",
      editorCallback: this.cleanAllMarkdownViews.bind(this)
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onKeydown(event, view) {
    if (this.isDeletion(event)) {
      deletionHandler(view);
    } else if (!event.ctrlKey && !event.altKey && !event.metaKey && !event.shiftKey) {
      insertionHandler(view);
    }
  }
  isDeletion(event) {
    return this.settings.deletionKeys.some((key) => is(event, key));
  }
  cleanAllMarkdownViews() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian3.MarkdownView) {
        cleanerCallback(leaf.view.editor);
      }
    });
  }
  remakeViewPlugin() {
    this.viewPlugin.length = 0;
    this.viewPlugin.push(createViewPlugin(this));
    this.app.workspace.updateOptions();
  }
};
